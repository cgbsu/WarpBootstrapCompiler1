#include <Warp/Runtime/Compiler/NumericType.hpp>
#include <Warp/Parsing/NumericLiterals.hpp>
#include <Warp/Parsing/MathematicalExpressions.hpp>
#include <Warp/Utilities.hpp>
#include <ThirdParty/fpm/ios.hpp>
#include <Warp/Parsing/Terms.hpp>
#include <Warp/Testing/TestParser.hpp>
#include <Warp/Runtime/Compiler/SimpleExecutor.hpp>
#include <CppUTest/TestHarness.h>
#define WARP__TESTING__HEADER__TESTING__PARSE__TESTING__UTILITIES__HPP__CHECK__MACRO__REQUIRED CHECK
#include <Warp/Testing/ParseTestingUtilities.hpp>
/* This work is under the Copyright Christopher A. Greeley (2024) and it is distributed
* under the No Kill Do No Harm License, a legally non-binding sumemry is as follows: 
* 
* # No Kill Do No Harm Licence â€“ Summary
* 
* Based on version 0.3, July 2022 of the Do No Harm License
* 
* https://github.com/raisely/NoHarm
* 
* LEGALLY NON-BINDING SUMMARY OF THE TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
* 
* ## Licence Grants
* 
* You're allowed
* 
* - to distribute the licensed work,
* - to create, publish, sublicense and patent derivative works and
* - to put your modifications or your derivative work under a seperate licence,
* 
* free of charge. Though, filing patent litigation leads to the loss of the patent licence. Also, the licence grants don't include the right to use the licensor's trademarks.
* 
* ## Unethical Behaviour
* 
* You may not use the licensed work if you engage in:
* 
* - human rights violations,
* - environmental destruction,
* - warfare,
* - addictive/destructive products or services or
* - actions that frustrate:
*   * peace,
*   * access to human rights,
*   * peaceful assembly and association,
*   * a sustainable environment or
*   * democratic processes
*   * abortion
*   * euthanasia
*   * human embryonic stem cell research (if human organisms are killed in the process)
* - except for actions that may be contrary to "human rights" (or interpretations thereof), do not kill and that frustrate 
*   * abortion
*   * euthanasia
*   * killing
* and; the software must never be used to kill, including: abortion, euthanasia, human stem cell research, in war, or law enforcement or as a part of any lethal weapon
* 
* ## Contributions
* 
* Contributions to the licensed work must be licensed under the exact same licence.
* 
* ## Licence Notice
* 
* When distributing the licensed work or your derivative work, you must
* 
* - include a copy of this licence,
* - retain attribution notices,
* - state changes that you made and
* - not use the names of the author and the contributors to promote your derivative work.
* 
* If the licensed work includes a "NOTICE" text file with attribution notices, you must copy those notices to:
* 
* - a "NOTICE" file within your derivative work,
* - a place within the source code or the documentation or
* - a place within a display generated by your derivative work.
* 
* ## No Warranty or Liability
* 
* The licensed work is offered on an as-is basis without any warranty or liability. You may choose to offer warranty or liability for your derivative work, but only fully on your own responsibility. */



using namespace Warp::Testing;
using namespace Warp::Runtime::Compiler::SimpleExecutor;
using namespace Warp::Parsing;
using namespace Warp::Utilities;

template<auto ResultTagParameterConstant, auto InputTagParameterConstant>
using ParserTestTemplate = MathematicalExpressionParser<
		MathematicalExpressionTermsType, 
		NumericTypeResolver, 
		ResultTagParameterConstant, 
		InputTagParameterConstant
	>;

using WholeType = NumericTypeResolver<NumericTypeTag::Whole>::Type;
using IntegerType = NumericTypeResolver<NumericTypeTag::Integer>::Type;
using FixedType = NumericTypeResolver<NumericTypeTag::FixedPoint>::Type;
using CharType = NumericTypeResolver<NumericTypeTag::Character>::Type;
using BoolType = NumericTypeResolver<NumericTypeTag::Bool>::Type;

using UnderlyingWholeType = typename NumericTypeResolver<NumericTypeTag::Whole>::Type::UnderylingType;
using UnderlyingIntegerType = typename NumericTypeResolver<NumericTypeTag::Integer>::Type::UnderylingType;
using UnderlyingFixedType = typename NumericTypeResolver<NumericTypeTag::FixedPoint>::Type::UnderylingType;
using UnderlyingCharType = typename NumericTypeResolver<NumericTypeTag::Character>::Type::UnderylingType;
using UnderlyingBoolType = typename NumericTypeResolver<NumericTypeTag::Bool>::Type::UnderylingType;

using WholeParserType = ParserTestTemplate<NumericTypeTag::Whole, NumericTypeTag::Whole>;
using IntegerParserType = ParserTestTemplate<NumericTypeTag::Integer, NumericTypeTag::Integer>;
using FixedParserType = ParserTestTemplate<NumericTypeTag::FixedPoint, NumericTypeTag::FixedPoint>;

using WholeEnumType = WholeParserType::TypeSpecificMathematicalExpressionTermTags;
using IntegerEnumType = IntegerParserType::TypeSpecificMathematicalExpressionTermTags;
using FixedEnumType = FixedParserType::TypeSpecificMathematicalExpressionTermTags;

using WholeExpressionType = WholeParserType::Expression;
using IntegerExpressionType = IntegerParserType::Expression;
using FixedExpressionType = FixedParserType::Expression;

constexpr static const auto compare_value = [](
		const auto& left, 
		const auto& right, 
		bool debug, 
		std::source_location location
	)
{
	if(debug == true)
		std::cout << "Start Retrieving Value, with Expected: " << right << "\n";
	const auto actual = retrieve_value<
			typename NumericTagResolver<CleanType<decltype(right)>>::NumericType
		>(left.node.get(), debug).value();
	bool result = (actual == right);
	if(result == false) {
		std::cout << location.file_name() << ": " << location.line() 
				<< ": Comparision failure! With Actual: " << result 
				<< " vs. Expected: " << right << "\n";
	}
	return result;
};

template<auto TestParameterConstant>
auto parse_whole(bool debug = false, std::source_location location = std::source_location::current())
{
	if(debug == true)
		std::cout << "(Whole) Parsing: " << TestParameterConstant.string << "\n";
	auto result = runtime_parse<
				WholeParserType, 
				TestParameterConstant, 	
				WholeParserType::TypeSpecificMathematicalExpressionTermTags::Expression
			>(debug);
	if(result.has_value() == false) {
		std::cout << location.file_name() << ": " << location.line() 
				<< ": Failed to parse Whole with: " << TestParameterConstant.string << "\n";
	}
	return result;
}

template<auto TestParameterConstant>
auto parse_integer(bool debug = false, std::source_location location = std::source_location::current())
{
	if(debug == true)
		std::cout << "(Integer) Parsing: " << TestParameterConstant.string << "\n";
	auto result = runtime_parse<
				IntegerParserType, 
				TestParameterConstant, 	
				IntegerParserType::TypeSpecificMathematicalExpressionTermTags::Expression
			>(debug);
	if(result.has_value() == false) {
		std::cout << location.file_name() << ": " << location.line() 
				<< ": Failed to parse Integer with: " << TestParameterConstant.string << "\n";
	}
	return result;
}

template<auto TestParameterConstant>
auto parse_fixed(bool debug = false, std::source_location location = std::source_location::current())
{
	if(debug == true)
		std::cout << "(Fixed) Parsing: " << TestParameterConstant.string << "\n";
	auto result = runtime_parse<
			FixedParserType, 
			TestParameterConstant, 	
			FixedParserType::TypeSpecificMathematicalExpressionTermTags::Expression
		>(debug);
	if(result.has_value() == false) {
		std::cout << location.file_name() << ": " << location.line() 
				<< ": Failed to parse FixedPoint with: " << TestParameterConstant.string << "\n";
	}
	return result;
}

template<auto TestParameterConstant>
void print_whole(bool debug = false)
{
	const auto result = parse_whole<TestParameterConstant>(debug);
	std::cout << "\nWhole Result: " << TestParameterConstant.string 
			<< " = " << retrieve_value<NumericTypeResolver<NumericTypeTag::Whole>::Type>(
					result.value().node.get(), debug
				).value() << "\n\n";
}

template<auto TestParameterConstant>
void print_integer(bool debug = false)
{
	const auto result = parse_integer<TestParameterConstant>(debug);
	std::cout << "\nInteger Result: " << TestParameterConstant.string 
			<< " = " << retrieve_value<NumericTypeResolver<NumericTypeTag::Integer>::Type>(
					result.value().node, debug
				).value() << "\n\n";
}

template<auto TestParameterConstant>
void print_fixed(bool debug = false)
{
	const auto result = parse_fixed<TestParameterConstant>(debug);
	std::cout << "\nFixed Result: " << TestParameterConstant.string 
			<< " = " << retrieve_value<NumericTypeResolver<NumericTypeTag::FixedPoint>::Type>(
					result.value().node, debug
				).value() << "\n\n";
}


template<auto TestParameterConstant>
void whole_test(
		UnderlyingWholeType expected, 
		bool debug = false, 
		std::source_location location = std::source_location::current()
	)
{
	check_parse<compare_value>(
			parse_whole<TestParameterConstant>(debug, location) /*Actual*/, 
			expected, /*Expected*/
			debug, 
			location
		);
}


template<auto TestParameterConstant>
void integer_test(
		UnderlyingIntegerType expected, 
		bool debug = false, 
		std::source_location location = std::source_location::current()
	)
{
	check_parse<compare_value>(
			parse_integer<TestParameterConstant>(debug, location) /*Actual*/, 
			expected, /*Expected*/
			debug, 
			location
		);
}

template<auto TestParameterConstant> 
void fixed_test(
		UnderlyingFixedType expected, 
		bool debug = false, 
		std::source_location location = std::source_location::current()
	)
{ 
		check_parse<compare_value>(
			parse_fixed<TestParameterConstant>(debug, location) /*Actual*/, 
			expected, /*Expected*/
			debug, 
			location
		);
}

void math_check(bool value) {
	CHECK(value);
}

TEST_GROUP(MathematicalExpressions) {};

bool compare_fixed(const SyntaxNode& left, FixedType right, bool debug, std::source_location location)
{
	if(debug == true) {
		std::cout << location.file_name() << ": " << location.line() 
				<< ": Start Retrieving Value, with Expected: " << right.number.to_double() << "\n";
	}
	return retrieve_value<FixedType>(left.get(), debug).value() == right;
}

TEST(MathematicalExpressions, InputAddition)
{
	bool debug = false;
	whole_test<FixedString{"1u + 1u"}>(2u, debug);
	whole_test<FixedString{"1 + 1"}>(2u, debug);
	whole_test<FixedString{"5 + 3"}>(8u, debug);
	whole_test<FixedString{"5u8 + 3u8"}>(8u, debug);
	integer_test<FixedString{"9i8 + 3i5"}>(12u, debug);
	integer_test<FixedString{"9i8 + 3i8 + 10i"}>(22, debug);
	fixed_test<FixedString{"16.16xp + 16.16xp"}>(FixedType{32, 32}, debug);
};

TEST(MathematicalExpressions, InputSubraction)
{
	bool debug = false;
	integer_test<FixedString{"5i - 3i"}>(2, debug);
	whole_test<FixedString{"5 - 3"}>(2, debug);
	integer_test<FixedString{"5i - 10i"}>(-5, debug);
	//std::cout << "RTF: " << parse_integer<FixedString{"5i - 10i - 8i"}>(true).value().value.number << "\n";
	integer_test<FixedString{"5i - 10i - 8i"}>(-13, debug);
	fixed_test<FixedString{"16.16xp - 8.8xp"}>(FixedType{7, 36}, debug);
	//std::cout << "RTF: " << parse_fixed<FixedString{"16.16xp - 8.8xp - 1.xp - 2.2xp"}>(true).value().value.number << "\n";
	fixed_test<FixedString{"16.16xp - 8.8xp - 1.xp - 2.2xp"}>(FixedType{4, 16}, debug);
};

TEST(MathematicalExpressions, InputSums)
{
	bool debug = false;
	integer_test<FixedString{"5i - 10i + 14i - 1i"}>(8, debug);
	integer_test<FixedString{"5i - 10i + 14i - 1i - 23i"}>(-15, debug);
};

TEST(MathematicalExpressions, InputMultiplication)
{
	bool debug = false;
	whole_test<FixedString{"5u * 3u"}>(15, debug);
	whole_test<FixedString{"5u * 3u * 20u"}>(300, debug);
	whole_test<FixedString{"5u * 3u * 20u * 44u"}>(13200, debug);
};

TEST(MathematicalExpressions, InputNegation)
{
	bool debug = false;
	integer_test<FixedString{"-44i"}>(-44, debug);
	integer_test<FixedString{"5i * -3i * -20i * 44i"}>(13200, debug);
	integer_test<FixedString{"5i * -3i * -20i * 44i"}>(13200, debug);
	integer_test<FixedString{"5i * -3i * -20i * -44i"}>(-13200, debug);
	integer_test<FixedString{"-5i * -3i * -20i * 44i"}>(-13200, debug);
	integer_test<FixedString{"-5i * -3i * -20i * -44i"}>(13200, debug);
};

TEST(MathematicalExpressions, InputDivision)
{
	bool debug = false;
	whole_test<FixedString{"15u / 3u"}>(5, debug);
	whole_test<FixedString{"60u / 3u / 20u"}>(1, debug);
	whole_test<FixedString{"126 / 7 / 3 / 2"}>(3, debug);
};

TEST(MathematicalExpressions, MixingBasicSumsAndProducts)
{
	bool debug = false;

	whole_test<FixedString{"5u * 3u + 8u * 7u"}>(71, debug);
	whole_test<FixedString{"4u + 5u * 3u - 21u / 7u"}>(16, debug);
	whole_test<FixedString{"5u * 3u - 21u / 7u"}>(12, debug);
	whole_test<FixedString{"5u * 3u * 21u / 7u + 4u"}>(49, debug);
	whole_test<FixedString{"5u * 3u * 21u / 7u + 4u + 8u"}>(57, debug);
	whole_test<FixedString{"5u * 3u * 21u / 7u + 4u * 8u"}>(77, debug);
	whole_test<FixedString{"6u + 5u * 3u - 21u / 7u + 4u"}>(22, debug);
	whole_test<FixedString{"5u * 3u - 21u / 7u + 4u"}>(16, debug);
	whole_test<FixedString{"5u * 3u * 21u / 7u + 4u"}>(49, debug);
};

TEST(MathematicalExpressions, BareParenthesis)
{
	bool debug = false;

	whole_test<FixedString{"(1)"}>(1, debug);
	whole_test<FixedString{"6u + 5u * 3u - (21u / 7u + 4u)"}>(14, debug);
	whole_test<FixedString{"(6u + 5u) * 3u - 21u / 7u + 4u"}>(34, debug);
	whole_test<FixedString{"(6u + 5u) * 3u - 33u / (7u + 4u)"}>(30, debug);
	
	integer_test<FixedString{"6i + (5i * 3i - 3102i) / 7i + 4i"}>(-431, debug);

	//integer_test<FixedString{"6i + (5i * 3i - 3102i) / 7i + 4i"}>(-431, debug);
	//
	whole_test<FixedString{"5u * (3u * 21u / 7u) + 4u"}>(49, debug);
	whole_test<FixedString{"5u * 3u * 21u / (7u + 4u + 10u)"}>(15, debug);
};


TEST(MathematicalExpressions, NestedParenthesis)
{
	bool debug = false;

	whole_test<FixedString{"3 * (4 * (4 + 4) + 6 * (2 + 3))"}>(186, debug);
	whole_test<FixedString{"3 * (4 * (4 + 4) + 6 * (2 + ((2 + 4) / 2)))"}>(186, debug);
	whole_test<FixedString{"3 * (4 * (4 + 4) + (2 + 3) * (2 + ((2 + 4) / 2)))"}>(171, debug);
	whole_test<FixedString{"3* ((4 * (4 + 4) + (2 + 3)) * (2 + ((2 + 4) / 2)))"}>(555, debug);
};

