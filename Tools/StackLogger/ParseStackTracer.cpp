#include <iostream>
#include <string>
#include <string_view>
#include <sstream>
#include <variant>
#include <vector>
#include <queue>
#include <optional>
#include <filesystem>
#include <fstream>
#include <source_location>
#include <charconv>

#include <ctpg/ctpg.hpp>

#include <Warp/Utilities.hpp>
/* This work is under the Copyright Christopher A. Greeley (2024) and it is distributed
* under the No Kill Do No Harm License, a legally non-binding sumemry is as follows: 
* 
* # No Kill Do No Harm Licence â€“ Summary
* 
* Based on version 0.3, July 2022 of the Do No Harm License
* 
* https://github.com/raisely/NoHarm
* 
* LEGALLY NON-BINDING SUMMARY OF THE TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
* 
* ## Licence Grants
* 
* You're allowed
* 
* - to distribute the licensed work,
* - to create, publish, sublicense and patent derivative works and
* - to put your modifications or your derivative work under a seperate licence,
* 
* free of charge. Though, filing patent litigation leads to the loss of the patent licence. Also, the licence grants don't include the right to use the licensor's trademarks.
* 
* ## Unethical Behaviour
* 
* You may not use the licensed work if you engage in:
* 
* - human rights violations,
* - environmental destruction,
* - warfare,
* - addictive/destructive products or services or
* - actions that frustrate:
*   * peace,
*   * access to human rights,
*   * peaceful assembly and association,
*   * a sustainable environment or
*   * democratic processes
*   * abortion
*   * euthanasia
*   * human embryonic stem cell research (if human organisms are killed in the process)
* - except for actions that may be contrary to "human rights" (or interpretations thereof), do not kill and that frustrate 
*   * abortion
*   * euthanasia
*   * killing
* and; the software must never be used to kill, including: abortion, euthanasia, human stem cell research, in war, or law enforcement or as a part of any lethal weapon
* 
* ## Contributions
* 
* Contributions to the licensed work must be licensed under the exact same licence.
* 
* ## Licence Notice
* 
* When distributing the licensed work or your derivative work, you must
* 
* - include a copy of this licence,
* - retain attribution notices,
* - state changes that you made and
* - not use the names of the author and the contributors to promote your derivative work.
* 
* If the licensed work includes a "NOTICE" text file with attribution notices, you must copy those notices to:
* 
* - a "NOTICE" file within your derivative work,
* - a place within the source code or the documentation or
* - a place within a display generated by your derivative work.
* 
* ## No Warranty or Liability
* 
* The licensed work is offered on an as-is basis without any warranty or liability. You may choose to offer warranty or liability for your derivative work, but only fully on your own responsibility. */



using namespace Warp::Utilities;

constexpr static const auto log_entry_start_pattern = FixedString{"\\[\\d+:\\d+\\]"};
constexpr static const auto regex_match_start_pattern = FixedString{"\\[\\d+:\\d+\\]\\s+"};
constexpr static const auto word_pattern = FixedString{"\\w"};
constexpr static const auto number_pattern = FixedString{"\\d+"};
constexpr static const auto single_anything_pattern = FixedString{"."};

constexpr static const auto reduce_rule_string = FixedString{"Reduced using rule"};
constexpr static const auto rr_conflict_string = FixedString{"R/R conflict encountered"};
constexpr static const auto end_of_file_string = FixedString{"<eof>"};
constexpr static const auto shift_to_string = FixedString{"Shift to"};
constexpr static const auto term_string = FixedString{"term:"};
constexpr static const auto reduce_operator_string = FixedString{"<-"};
constexpr static const auto parse_log_string = FixedString{"PARSE:"};
constexpr static const auto regex_match_log_string = FixedString{"REGEX MATCH:"};

constexpr static const auto log_entry_start = ctpg::regex_term<log_entry_start_pattern.string>("LogEntryStart");
constexpr static const auto number = ctpg::regex_term<number_pattern.string>("Number");
constexpr static const auto word = ctpg::regex_term<word_pattern.string>("Word");
constexpr static const auto single_anything = ctpg::regex_term<single_anything_pattern.string>("SingleAnything");


constexpr static const auto regex_match = ctpg::regex_term<regex_match_log_string.string>("RegexMatchStart");
constexpr static const auto parse_log = ctpg::regex_term<parse_log_string.string>("RegexMatchStart");
constexpr static const auto reduce_rule = ctpg::string_term(reduce_rule_string.string);
constexpr static const auto rr_conflict = ctpg::string_term(rr_conflict_string.string);
constexpr static const auto end_of_file = ctpg::string_term(end_of_file_string.string);
constexpr static const auto shift_to = ctpg::string_term(shift_to_string.string);
constexpr static const auto term = ctpg::string_term(term_string.string);
constexpr static const auto reduce_operator = ctpg::string_term(reduce_operator_string.string);

constexpr static const auto comma = ctpg::char_term(',');
constexpr static const auto colon = ctpg::char_term(':');

struct Reduction {
	std::string what;
	std::vector<std::string> from;
};

struct RRConflict {}; // Just to to help distinguish it //

using StackElement = std::variant<Reduction, std::string, RRConflict>;
using Stack = std::vector<StackElement>;

struct StackLog {
	Stack stack;
	std::queue<Stack> log;
};

constexpr static const auto reduction = ctpg::nterm<Reduction>("Reduction");
constexpr static const auto shift = ctpg::nterm<std::string>("Shift");
constexpr static const auto rr_conflict_log = ctpg::nterm<Reduction>("RRConflictLog");
constexpr static const auto stack = ctpg::nterm<Stack>("Stack");

consteval auto rules()
{
	return ctpg::rules(
			reduction(log_entry_start, parse_log, reduce_rule, number, word, reduce_operator, word)
			>= [](auto, auto, auto, auto, auto to, auto, auto from) {
				return Reduction{std::string{to}, std::vector{std::string{from}}};
			}, 
			stack(reduction)
			>>= [](auto& log, auto reduction) {
				log.stack.push_back(StackElement{Reduction{reduction}});
			}
		);
}

constexpr ctpg::parser parser_log_parser(
		stack, 
		ctpg::terms(
				log_entry_start, 
				number, 
				word, 
				regex_match, 
				parse_log, 
				regex_match, 
				single_anything, 
				reduce_rule, 
				reduce_operator
			), 
		ctpg::nterms(
				reduction, 
				shift, 
				rr_conflict_log, 
				stack
			), 
		rules()
	);

Stack parse_log_from_string(const std::string_view log);

std::string read_file(const std::filesystem::path log_path);

void test_parse_reduction();

int main(int argc, char** args)
{
	//const auto sample_log = read_file(std::filesystem::path("sample_log.ctpg"));
	//parse_log_from_string(sample_log);
	test_parse_reduction();
	return 0;
}

Stack parse_log_from_string(const std::string_view log) {
	return Stack{};
}

std::string read_file(const std::filesystem::path log_path) {
	return std::string{};
}

template<auto TestParameterConstant, auto CompareParameterConstant>
bool check(auto expected, std::source_location location = std::source_location::current())
{
	StackLog log;
	if(auto result = parser_log_parser.context_parse(
					log, 
					ctpg::buffers::string_buffer(TestParameterConstant.string), 
					std::cerr
				);
				result.has_value() == true
			)
	{
		if(CompareParameterConstant(log, expected) == false) {
			throw std::string{"Match Failed! " } + std::to_string(location.line());
			return false;
		}
		return true;
	}
	else {
		throw std::string{"Invalid Result! " } + std::to_string(location.line());
		return false;
	}
}

bool last_reduction_string_value(const StackLog& actual, std::string expected)
{
	if(std::holds_alternative<Reduction>(actual.stack.back()) == true)
		return std::get<Reduction>(actual.stack.back()).what == expected;
	return false;
}

void test_parse_reduction()
{
	check<
			FixedString{"[1:17] PARSE: Reduced using rule 0  Digits <- Base10Digits"}, 
			last_reduction_string_value
		>(std::string{"Digits"});
}

