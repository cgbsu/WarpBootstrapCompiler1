#include <Warp/Common.hpp>
#include <Warp/Utilities/Conversions.hpp>
/* This work is under the Copyright Christopher A. Greeley (2024) and it is distributed
* under the No Kill Do No Harm License, a legally non-binding sumemry is as follows: 
* 
* # No Kill Do No Harm Licence â€“ Summary
* 
* Based on version 0.3, July 2022 of the Do No Harm License
* 
* https://github.com/raisely/NoHarm
* 
* LEGALLY NON-BINDING SUMMARY OF THE TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
* 
* ## Licence Grants
* 
* You're allowed
* 
* - to distribute the licensed work,
* - to create, publish, sublicense and patent derivative works and
* - to put your modifications or your derivative work under a seperate licence,
* 
* free of charge. Though, filing patent litigation leads to the loss of the patent licence. Also, the licence grants don't include the right to use the licensor's trademarks.
* 
* ## Unethical Behaviour
* 
* You may not use the licensed work if you engage in:
* 
* - human rights violations,
* - environmental destruction,
* - warfare,
* - addictive/destructive products or services or
* - actions that frustrate:
*   * peace,
*   * access to human rights,
*   * peaceful assembly and association,
*   * a sustainable environment or
*   * democratic processes
*   * abortion
*   * euthanasia
*   * human embryonic stem cell research (if human organisms are killed in the process)
* - except for actions that may be contrary to "human rights" (or interpretations thereof), do not kill and that frustrate 
*   * abortion
*   * euthanasia
*   * killing
* and; the software must never be used to kill, including: abortion, euthanasia, human stem cell research, in war, or law enforcement or as a part of any lethal weapon
* 
* ## Contributions
* 
* Contributions to the licensed work must be licensed under the exact same licence.
* 
* ## Licence Notice
* 
* When distributing the licensed work or your derivative work, you must
* 
* - include a copy of this licence,
* - retain attribution notices,
* - state changes that you made and
* - not use the names of the author and the contributors to promote your derivative work.
* 
* If the licensed work includes a "NOTICE" text file with attribution notices, you must copy those notices to:
* 
* - a "NOTICE" file within your derivative work,
* - a place within the source code or the documentation or
* - a place within a display generated by your derivative work.
* 
* ## No Warranty or Liability
* 
* The licensed work is offered on an as-is basis without any warranty or liability. You may choose to offer warranty or liability for your derivative work, but only fully on your own responsibility. */



#ifndef WARP__PARSING__HEADER__PARSING__TERMS_HPP
#define WARP__PARSING__HEADER__PARSING__TERMS_HPP

namespace Warp::Parsing
{
	template<
			auto TagParameterConstant, 
			template<auto...> typename TermParameterTemplate, 
			auto... RequiredTermParameterConstants
		>
	struct TreeTerm
	{
		template<int PrecedenceParameterConstant>
		using InjectedTermType = TermParameterTemplate<
				RequiredTermParameterConstants..., 
				PrecedenceParameterConstant
			>;
		template<int PrecedenceParameterConstant>
		constexpr static const auto term = InjectedTermType<
				PrecedenceParameterConstant
			>::term;
		constexpr static const auto tag = TagParameterConstant;
	};

	template<
			auto TagParameterConstant, 
			template<typename, auto...> typename TermParameterTemplate, 
			typename ParameterType, 
			auto RequiredTermParameterConstants
		>
	struct TypeTreeTerm
	{
		template<int PrecedenceParameterConstant>
		using InjectedTermType = TermParameterTemplate<
				ParameterType, 
				RequiredTermParameterConstants 
				//PrecedenceParameterConstant
			>;
		template<int PrecedenceParameterConstant>
		constexpr static const auto term = InjectedTermType<
				PrecedenceParameterConstant
			>::term;
		constexpr static const auto tag = TagParameterConstant;
	};


	namespace Detail
	{
		struct AssociatedTemplateConstructable0
		{
			template<
					template<auto, template<auto...> typename, auto...> 
							typename AssociationParameterType, 
					auto TagParameterConstant, 
					template<auto...> typename AssociatedTemplateParameterTemplate, 
					auto... ParameterConstants 
				>
			AssociatedTemplateConstructable0(TypeHolder<AssociationParameterType<
					TagParameterConstant, 
					AssociatedTemplateParameterTemplate, 
					ParameterConstants...>>
				) {}
		};

		struct AssociatedTemplateConstructable1
		{
			template<
					template<auto, template<typename, auto...> typename, typename, auto...> 
							typename AssociationParameterType, 
					auto TagParameterConstant, 
					template<typename, auto...> typename AssociatedTemplateParameterTemplate, 
					typename ParameterType, 
					auto... ParameterConstants 
				>
			AssociatedTemplateConstructable1(TypeHolder<AssociationParameterType<
					TagParameterConstant, 
					AssociatedTemplateParameterTemplate, 
					ParameterType, 
					ParameterConstants...>>
				) {}
		};
	}

	template<typename TreeTermParameterType>
	concept AssociatedTreeTermTemplateConcept = requires(TreeTermParameterType canidate) {
		Detail::AssociatedTemplateConstructable0(TypeHolder<decltype(canidate)>{});
	}; 

	template<typename TypeTreeTermParameterType>
	concept AssociatedTypeTreeTermTemplateConcept = requires(TypeTreeTermParameterType canidate) {
		Detail::AssociatedTemplateConstructable1(TypeHolder<decltype(canidate)>{});
	}; 
	
	template<typename AssociatedTemplateParameterType>
	concept AssociatedTemplateConcept 
		= AssociatedTreeTermTemplateConcept<AssociatedTemplateParameterType>
				|| AssociatedTypeTreeTermTemplateConcept<AssociatedTemplateParameterType>;

	template<typename>
	struct IsTermHelper {
		constexpr static const bool value = false;
	};

	template<AssociatedTreeTermTemplateConcept TermParameterType>
	struct IsTermHelper<TermParameterType> {
		using Type = TermParameterType;
		constexpr static const bool value = true;
	};

	template<typename CanidateParameterType>
	constexpr static const bool is_term = IsTermHelper<CanidateParameterType>::value;

	template<typename>
	struct IsTypeTermHelper {
		constexpr static const bool value = false;
	};

	template<AssociatedTypeTreeTermTemplateConcept TermParameterType>
	struct IsTypeTermHelper<TermParameterType> {
		using Type = TermParameterType;
		constexpr static const bool value = true;
	};

	template<typename CanidateParameterType>
	constexpr static const bool is_type_term = IsTypeTermHelper<CanidateParameterType>::value;

	// This does not work... Im not sure why...
	template<typename CanidateParameterType>
	concept TermInjectableConcept = CanidateParameterType::template InjectedTermType<0>;

	template<
			size_t IndexParamterConstant, 
			auto TagParameterConstant, 
			AssociatedTemplateConcept CurrentParameterType, 
			AssociatedTemplateConcept... TermParameterTypes
		>
	consteval static const std::optional<size_t> find_term_with_tag_index()
	{
		if constexpr(TagParameterConstant == CurrentParameterType::tag)
			return IndexParamterConstant;
		if constexpr(sizeof...(TermParameterTypes) <= 0)
			return std::nullopt;
		else
		{
			return find_term_with_tag_index<
					IndexParamterConstant + 1, 
					TagParameterConstant, 
					TermParameterTypes...
				>();
		}
	};

	template<
			bool ErrorOnNoMatchParameterConstant, 
			auto TagParameterConstant, 
			AssociatedTemplateConcept CurrentParameterType, 
			AssociatedTemplateConcept... TermParameterTypes
		>
	consteval auto get_term_with_tag()
	{
		if constexpr(equal_if_comparible<
					TagParameterConstant, 
					CurrentParameterType::tag
				>() == true)
			return TypeHolder<CurrentParameterType>();
		else if constexpr(sizeof...(TermParameterTypes) <= 0)
		{
			static_assert(
					ErrorOnNoMatchParameterConstant, 
					"Term not found in get_term_with_tag"
				);
			return std::nullopt;
		}
		else
		{
			return get_term_with_tag<
					ErrorOnNoMatchParameterConstant, 
					TagParameterConstant, 
					TermParameterTypes...
				>();
		}
	}

	template<
			bool ErrorOnNoMatchParameterConstant, 
			auto TagParameterConstant, 
			AssociatedTemplateConcept... TermParameterTypes
		>
	using TreeTermWithTag = decltype(get_term_with_tag<
			ErrorOnNoMatchParameterConstant, 
			TagParameterConstant, 
			TermParameterTypes...
		>())::Type;

	enum class TermPrecedence : int {
		NoPriority = 0
	};

	using TermsNoPreviousType = void;

	template<
			typename PreviousParameterType, 
			auto PrecedenceParameterConstant, 
			AssociatedTemplateConcept... TermParameterTypes
		>
	struct Terms
	{
		using NoPreviousType = TermsNoPreviousType;
		using PreviousType = PreviousParameterType;
		constexpr static const auto precedence = PrecedenceParameterConstant;
		using ThisType = Terms<
				PreviousParameterType, 
				precedence, 
				TermParameterTypes...
			>;
		using PrecedenceType = decltype(precedence);
		constexpr static const auto is_root = std::is_same_v<NoPreviousType, PreviousType>;

		template<auto TagParameterConstant>
		consteval static auto get_term()
		{
			if constexpr(auto result = get_term_with_tag<
						std::is_void_v<PreviousType> == false, 
						TagParameterConstant, 
						TermParameterTypes...
					>(); std::is_same<decltype(result), std::nullopt_t>::value == false)
				return result;
			else
				return PreviousType::template get_term<TagParameterConstant>();
		}

		template<auto TagParameterConstant>
		consteval static auto get_term_precedence()
		{
			if constexpr(auto result = get_term_with_tag<
						std::is_void_v<PreviousType> == false, 
						TagParameterConstant, 
						TermParameterTypes...
					>(); std::is_same<decltype(result), std::nullopt_t>::value == false)
				return precedence;
			else
				return PreviousType::template get_term_precedence<TagParameterConstant>();
		}

		template<auto TagParameterConstant>
		using TermType = decltype(get_term<TagParameterConstant>())::Type;

		template<auto TagParameterConstant>
		constexpr static const auto term  = TermType<TagParameterConstant>
				::template term<static_cast<int>(precedence)>;


		template<AssociatedTemplateConcept... NewTermParameterTypes>
		using AddOnePriority = Terms<
				ThisType, 
				static_cast<int>(precedence) + 1, 
				NewTermParameterTypes...
			>;


		template<typename NewPreviousParameterType, auto NewPreviousParameterConstant>
		using ReplacePrevious = Terms<
				NewPreviousParameterType, 
				NewPreviousParameterConstant, 
				TermParameterTypes...
			>;
		
		template<typename NewPreviousParameterType>
		using ReplacePreviousAddOnePriority = ReplacePrevious<
				NewPreviousParameterType, 
				NewPreviousParameterType::precedence + 1
			>;

		template<AssociatedTemplateConcept... NewPreviousTermParameterTypes>
		using InjectPreviousAddOnePriority 
				= ReplacePreviousAddOnePriority<Terms<PreviousType, precedence, NewPreviousTermParameterTypes...>>;

		template<AssociatedTemplateConcept... NewTermParameterTypes>
		using ReplaceTerms = Terms<PreviousType, precedence, NewTermParameterTypes...>;

		template<AssociatedTemplateConcept... NewTermParameterTypes>
		using AppendTerms = Terms<PreviousType, precedence, TermParameterTypes..., NewTermParameterTypes...>;

		template<
				typename OtherPreviousParameterType, 
				auto OtherPrecedenceParameterConstant, 
				AssociatedTemplateConcept... NewTermParameterTypes, 
				typename... NextToAppendParameterTypes
			>
		constexpr static const auto append_terms(
				Terms<
						OtherPreviousParameterType, 
						OtherPrecedenceParameterConstant, 
						NewTermParameterTypes...
					>, 
				NextToAppendParameterTypes... next
			)
		{
			using NextType = Terms<PreviousType, precedence, TermParameterTypes..., NewTermParameterTypes...>;
			if constexpr(sizeof...(NextToAppendParameterTypes) <= 0)
				return NextType{};
			else {
				return NextType::append_terms(next...);
			}
		}

		template<typename ToPrependParameterType>
		constexpr static const auto prepend()
		{
			if constexpr(is_root == true)
				return TypeHolder<Terms<ToPrependParameterType, 1, TermParameterTypes...>>{};
			else
			{
				return TypeHolder<Terms<
						typename decltype(PreviousType::template prepend<ToPrependParameterType>())::Type, 
						precedence + 1, 
						TermParameterTypes...
					>>{};
			}
		}

		template<AssociatedTemplateConcept... NewTermParameterTypes>
		using Prepend = decltype(prepend<Terms<NoPreviousType, 0, NewTermParameterTypes...>>())::Type;

		template<
				typename OtherPreviousParameterType, 
				auto OtherPrecedenceParameterConstant
			>
		constinit static const bool can_flat_merge = (
						std::is_same_v<OtherPreviousParameterType, NoPreviousType> 
						|| is_root == true
						|| std::is_same_v<OtherPreviousParameterType, PreviousType>
					)
				&& OtherPrecedenceParameterConstant == precedence;

		template<
				typename OtherPreviousParameterType, 
				auto OtherPrecedenceParameterConstant, 
				typename... OtherTermParameterTypes
			>
		constexpr const static auto flat_merge(Terms<
				OtherPreviousParameterType, 
				OtherPrecedenceParameterConstant, 
				OtherTermParameterTypes...
			> other)
		requires(ThisType::template can_flat_merge<
					OtherPreviousParameterType, 
					OtherPrecedenceParameterConstant
				> == true) 
		{
			if constexpr(is_root == false)
			{
				return TypeHolder<Terms<
						PreviousType, 
						precedence, 
						TermParameterTypes..., 
						OtherTermParameterTypes...
					>>{};
			}
			else 
			{
				return TypeHolder<Terms<
						OtherPreviousParameterType, 
						precedence, 
						TermParameterTypes..., 
						OtherTermParameterTypes...
					>>{};
			}
		}

		template<typename OtherTermParameterType>
		using FlatMerge = decltype(flat_merge(std::declval<OtherTermParameterType>()))::Type;

		template<
				bool ReduceToNonTerminalTermsParameterConstant, 
				typename CurrentParameterType, 
				AssociatedTemplateConcept... CanidateTermParameterTypes, 
				typename... CurrentTermsParameterTypes
			>
		consteval static const auto filter_terms_implementation(
				const std::tuple<PlaceHolder, CurrentTermsParameterTypes...> terms
			)
		{
			if constexpr(
					(ReduceToNonTerminalTermsParameterConstant == false 
							&& is_term<CurrentParameterType> == true)
					|| (ReduceToNonTerminalTermsParameterConstant == true 
							&& is_type_term<CurrentParameterType> == true)
				)
			{
				using NextTermsType = decltype(std::tuple_cat(
						terms, 
						std::tuple{std::declval<CurrentParameterType>()}
					));
				if constexpr(sizeof...(CanidateTermParameterTypes) > 0)
				{
					return filter_terms_implementation<
							ReduceToNonTerminalTermsParameterConstant, 
							CanidateTermParameterTypes...
						>(std::declval<NextTermsType>());
				}
				else
					return std::declval<NextTermsType>();
			}
		}

		template<bool ReduceToNonTerminalTermsParameterConstant>
		consteval static const auto filter_terms()
		{
			return filter_terms_implementation<
					ReduceToNonTerminalTermsParameterConstant, 
					TermParameterTypes...
				>(std::tuple{PlaceHolder{}});
		}

		template<bool ReduceToNonTerminalTermsParameterConstant>
		using FilteredTermsType = decltype(filter_terms<
				ReduceToNonTerminalTermsParameterConstant
			>());

		template<bool ReduceToNonTerminalTermsParameterConstant>
		consteval static const auto recursive_filter_to_terms()
		{
			using CurrentType = FilteredTermsType<ReduceToNonTerminalTermsParameterConstant>;
			if constexpr(is_root == false)
			{
				constinit static auto next = PreviousType
						::template recursive_filter_to_terms<
								ReduceToNonTerminalTermsParameterConstant
							>();
				if constexpr(std::tuple_size_v<decltype(next)> > 1)
					return std::tuple_cat(next, std::declval<TupleAfterFirstType<CurrentType>>());
				else
					return std::declval<CurrentType>();
			}
			else 
				return std::declval<CurrentType>();
		}

		template<bool ReduceToNonTerminalTermsParameterConstant>
		using RecursivleyFilteredTermsType = decltype(
				recursive_filter_to_terms<ReduceToNonTerminalTermsParameterConstant>()
			);

		template<bool ReduceToNonTerminalTermsParameterConstant, 
				size_t... TermIndexParameterConstants>
		consteval static const auto create_terms_implementation(
				std::index_sequence<TermIndexParameterConstants...> 
			)
		{
			constinit static const auto tree_terms = recursive_filter_to_terms<
					ReduceToNonTerminalTermsParameterConstant
				>();
			return std::tuple{std::get<TermIndexParameterConstants>(tree_terms)...};
		}
		template<bool ReduceToNonTerminalTermsParameterConstant, 
				size_t... TermIndexParameterConstants>
		consteval static const auto create_terms()
		{
			using RecursivleyFilteredType
					= RecursivleyFilteredTermsType<
							ReduceToNonTerminalTermsParameterConstant
						>;
			if constexpr(std::is_same_v<RecursivleyFilteredType, std::nullopt_t> == true 
					|| std::is_same_v<RecursivleyFilteredType, void>)
				return std::nullopt;
			else
			{
				return create_terms_implementation(
						std::make_index_sequence<std::tuple_size_v<RecursivleyFilteredType
					>>());
			}
		}
	};

	template<AssociatedTemplateConcept... MakeTermParameterTypes>
	using MakeTerms = Terms<void, 0, MakeTermParameterTypes...>;

	template<
			typename LeftPreviousParameterType, 
			auto LeftPrecedentParameterConstant, 
			typename... LeftTermParameterTypes, 
			typename RightPreviousParameterType, 
			auto RightPrecedentParameterConstant, 
			typename... RightTermParameterTypes
		>
	constexpr const static auto merge_terms( 
			Terms<
				LeftPreviousParameterType, 
				LeftPrecedentParameterConstant, 
				LeftTermParameterTypes...
			> left, 
			Terms<
				RightPreviousParameterType, 
				RightPrecedentParameterConstant, 
				RightTermParameterTypes...
			> right
		)
	requires(decltype(left)::template can_flat_merge<
					RightPreviousParameterType, 
					RightPrecedentParameterConstant
			>
		) // Merging Right INTO Left "equal" case
	{
		return decltype(left)::flat_merge(right);
	}

	template<
			typename LeftPreviousParameterType, 
			auto LeftPrecedentParameterConstant, 
			typename... LeftTermParameterTypes, 
			typename RightPreviousParameterType, 
			auto RightPrecedentParameterConstant, 
			typename... RightTermParameterTypes
		>
	requires(
			RightPrecedentParameterConstant < LeftPrecedentParameterConstant 
					&& (RightPrecedentParameterConstant > LeftPreviousParameterType::precedence
							|| std::same_as<LeftPreviousParameterType, TermsNoPreviousType>)
		)
	constexpr const static auto merge_terms( // Merginer Right INTO Left "in-between" case
			Terms<
				LeftPreviousParameterType, 
				LeftPrecedentParameterConstant, 
				LeftTermParameterTypes...
			> left, 
			Terms<
				RightPreviousParameterType, 
				RightPrecedentParameterConstant, 
				RightTermParameterTypes...
			> right
		)
	{
		using LeftTermsType = decltype(left);
		using RightTermsType = decltype(right);
		using LeftPreviousType = LeftPreviousParameterType;
		using RightPreviousType = RightPreviousParameterType;
		if constexpr(LeftTermsType::is_root == true)
		{
			return TypeHolder<Terms<
					RightTermsType, 
					LeftPrecedentParameterConstant, 
					LeftTermParameterTypes...
				>>{};
		}
		else if constexpr(RightTermsType::is_root == true)
		{
			return TypeHolder<Terms<
					Terms<
							LeftPreviousType, 
							RightPrecedentParameterConstant, 
							RightTermParameterTypes...
						>, 
					LeftPrecedentParameterConstant, 
					LeftTermParameterTypes...
				>>{};
		}
		else
		{
			using MergedPreviousType = decltype(merge_terms(
					std::declval<LeftPreviousType>(), 
					std::declval<RightPreviousType>()
				))::Type;
			using NewRightType = Terms<
					MergedPreviousType, 
					RightPrecedentParameterConstant, 
					RightTermParameterTypes...
				>;
			return TypeHolder<Terms<
					NewRightType, 
					LeftPrecedentParameterConstant, 
					LeftTermParameterTypes...
				>>{};
		}
	}

	template<
			typename LeftPreviousParameterType, 
			auto LeftPrecedentParameterConstant, 
			typename... LeftTermParameterTypes, 
			typename RightPreviousParameterType, 
			auto RightPrecedentParameterConstant, 
			typename... RightTermParameterTypes
		>
	requires(RightPrecedentParameterConstant > LeftPrecedentParameterConstant)
	constexpr const static auto merge_terms( // Merginer Right INTO Left "partial sorted/greater than" case
			Terms<
				LeftPreviousParameterType, 
				LeftPrecedentParameterConstant, 
				LeftTermParameterTypes...
			> left, 
			Terms<
				RightPreviousParameterType, 
				RightPrecedentParameterConstant, 
				RightTermParameterTypes...
			> right
		)
	{
		using LeftTermsType = decltype(left);
		using RightTermsType = decltype(right);
		using LeftPreviousType = LeftPreviousParameterType;
		using RightPreviousType = RightPreviousParameterType;
		if constexpr(RightTermsType::is_root == true)
		{
			return TypeHolder<Terms<
					LeftTermsType, 
					RightPrecedentParameterConstant, 
					RightTermParameterTypes...
				>>{};
		}
		else
		{
			using MergedPreviousType = decltype(merge_terms(
					std::declval<LeftTermsType>(), 
					std::declval<RightPreviousType>()
				))::Type;
			return TypeHolder<Terms<
					MergedPreviousType, 
					RightPrecedentParameterConstant, 
					RightTermParameterTypes...
				>>{};
		}
	}

	template<
			typename LeftPreviousParameterType, 
			auto LeftPrecedentParameterConstant, 
			typename... LeftTermParameterTypes, 
			typename RightPreviousParameterType, 
			auto RightPrecedentParameterConstant, 
			typename... RightTermParameterTypes
		>
	requires(RightPrecedentParameterConstant < LeftPrecedentParameterConstant 
			&& RightPrecedentParameterConstant < LeftPreviousParameterType::precedence)
	constexpr const static auto merge_terms( // Merginer Right INTO Left "less than" case
			Terms<
				LeftPreviousParameterType, 
				LeftPrecedentParameterConstant, 
				LeftTermParameterTypes...
			> left, 
			Terms<
				RightPreviousParameterType, 
				RightPrecedentParameterConstant, 
				RightTermParameterTypes...
			> right
		)
	{
		using LeftTermsType = decltype(left);
		using RightTermsType = decltype(right);
		using LeftPreviousType = LeftPreviousParameterType;
		using RightPreviousType = RightPreviousParameterType;
		using MergedPreviousType = decltype(merge_terms(
				std::declval<LeftPreviousType>(), 
				std::declval<RightTermsType>()
			))::Type;
		return TypeHolder<Terms<
				MergedPreviousType, 
				LeftPrecedentParameterConstant, 
				LeftTermParameterTypes...
			>>{};
	}
	
	template<typename LeftTermParameterType, typename RightTermParameterType>
	using MergeTerms = decltype(merge_terms(
			std::declval<LeftTermParameterType>(), 
			std::declval<RightTermParameterType>()
		))::Type;
}

#endif // WARP__PARSING__HEADER__PARSING__TERMS_HPP

