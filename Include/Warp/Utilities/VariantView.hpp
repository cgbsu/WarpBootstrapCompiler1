#include <Warp/Common.hpp>
/* This work is under the Copyright Christopher A. Greeley (2024) and it is distributed
* under the No Kill Do No Harm License, a legally non-binding sumemry is as follows: 
* 
* # No Kill Do No Harm Licence â€“ Summary
* 
* Based on version 0.3, July 2022 of the Do No Harm License
* 
* https://github.com/raisely/NoHarm
* 
* LEGALLY NON-BINDING SUMMARY OF THE TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
* 
* ## Licence Grants
* 
* You're allowed
* 
* - to distribute the licensed work,
* - to create, publish, sublicense and patent derivative works and
* - to put your modifications or your derivative work under a seperate licence,
* 
* free of charge. Though, filing patent litigation leads to the loss of the patent licence. Also, the licence grants don't include the right to use the licensor's trademarks.
* 
* ## Unethical Behaviour
* 
* You may not use the licensed work if you engage in:
* 
* - human rights violations,
* - environmental destruction,
* - warfare,
* - addictive/destructive products or services or
* - actions that frustrate:
*   * peace,
*   * access to human rights,
*   * peaceful assembly and association,
*   * a sustainable environment or
*   * democratic processes
*   * abortion
*   * euthanasia
*   * human embryonic stem cell research (if human organisms are killed in the process)
* - except for actions that may be contrary to "human rights" (or interpretations thereof), do not kill and that frustrate 
*   * abortion
*   * euthanasia
*   * killing
* and; the software must never be used to kill, including: abortion, euthanasia, human stem cell research, in war, or law enforcement or as a part of any lethal weapon
* 
* ## Contributions
* 
* Contributions to the licensed work must be licensed under the exact same licence.
* 
* ## Licence Notice
* 
* When distributing the licensed work or your derivative work, you must
* 
* - include a copy of this licence,
* - retain attribution notices,
* - state changes that you made and
* - not use the names of the author and the contributors to promote your derivative work.
* 
* If the licensed work includes a "NOTICE" text file with attribution notices, you must copy those notices to:
* 
* - a "NOTICE" file within your derivative work,
* - a place within the source code or the documentation or
* - a place within a display generated by your derivative work.
* 
* ## No Warranty or Liability
* 
* The licensed work is offered on an as-is basis without any warranty or liability. You may choose to offer warranty or liability for your derivative work, but only fully on your own responsibility. */



#ifndef WARP__UTILITIES__HEADER__UTILITIES__VARIANT__VIEW__HPP
#define WARP__UTILITIES__HEADER__UTILITIES__VARIANT__VIEW__HPP

namespace Warp::Utilities
{
	template<
	        typename BaseParameterType, 
	        template<auto> typename ChildParameterTemplate, 
	        auto... AlternativeTagParameterConstants
	    >
	struct VariantView
	{
		template<
				auto CurrentIndexParameterConstant, 
				auto TagParameterConstant, 
				auto CurrentCanidateParameterConstant, 
				auto... CanidateParamterConstants
			>
		constexpr static const size_t get_tag_index()
		{
			if constexpr(TagParameterConstant == CurrentCanidateParameterConstant)
				return CurrentIndexParameterConstant;
			else
			{
				return get_tag_index<
						CurrentIndexParameterConstant + 1, 
						TagParameterConstant, 
						CanidateParamterConstants... 
					>();
			}
		}
		
		template<auto TagParameterConstant>
		constexpr static const size_t tag_index 
				= get_tag_index<0, TagParameterConstant, AlternativeTagParameterConstants...>();

		using BaseType = BaseParameterType;

	    template<auto TagParameterConstant>
	    using ChildType = ChildParameterTemplate<TagParameterConstant>;

	    template<auto TagParameterConstant>
	    constexpr explicit VariantView(const ChildParameterTemplate<TagParameterConstant>* alternative) 
			: alternative_index(tag_index<TagParameterConstant>), 
			alternative(alternative) {}

	    constexpr size_t get_alternative_index() const {
	        return alternative_index;
	    }

	    constexpr const BaseType* get_alternative() const {
	        return alternative;
	    }
					
	    protected: 
	        size_t alternative_index;
	        const BaseType* alternative;
	};
	
	template<
	        typename ReturnParameterType, 
	        auto VisitorParameterConstant, 
	        typename BaseParameterType, 
	        template<auto> typename ChildParameterTemplate, 
	        auto CurrentAlternativeParameterConstant, 
	        auto... AlternativeTagParameterConstants, 
	        auto... AllAlternativeTagParameterConstants
	    >
	auto visit_implementation(
	        size_t current_alternative_index, 
	        const VariantView<
					BaseParameterType, 
					ChildParameterTemplate, 
					AllAlternativeTagParameterConstants...
				>& view, 
	        auto... additional_arguments
	    ) -> std::optional<ReturnParameterType>
	{
	    using VariantType = VariantView<
				BaseParameterType, 
				ChildParameterTemplate, 
				AllAlternativeTagParameterConstants...
			>;

	    if(current_alternative_index == view.get_alternative_index())
	    {
	        return VisitorParameterConstant(
	                static_cast<
	                        typename VariantType::ChildType<
									CurrentAlternativeParameterConstant
								> const*
	                    >(view.get_alternative()),
	                additional_arguments...
	            );
	    }
	    else
	    {
	        if constexpr(sizeof...(AlternativeTagParameterConstants) > 0)
	        {
	            return visit_implementation<
	                    ReturnParameterType, 
	                    VisitorParameterConstant, 
	                    BaseParameterType, 
	                    ChildParameterTemplate, 
	                    AlternativeTagParameterConstants...
	                >(
	                        current_alternative_index + 1, 
	                        view, 
	                        additional_arguments...
	                    );
	        }
	        else
	            return std::nullopt;
	    }
	}
	
	
	template<
	        typename ReturnParameterType, 
	        auto VisitorParameterConstant, 
	        typename BaseParameterType, 
	        template<auto> typename ChildParameterTemplate, 
	        auto... AlternativeTagParameterConstants
	    >
	auto visit(
	        const VariantView<
					BaseParameterType, 
					ChildParameterTemplate, 
					AlternativeTagParameterConstants...
				>& view, 
	        auto... additional_arguments
	    ) -> std::optional<ReturnParameterType>
	{
	    return visit_implementation< 
	                ReturnParameterType, 
	                VisitorParameterConstant, 
	                BaseParameterType, 
	                ChildParameterTemplate, 
	                AlternativeTagParameterConstants...
	        >(0, view, additional_arguments...);
	}
}

#endif // WARP__UTILITIES__HEADER__UTILITIES__VARIANT__VIEW__HPP

