#include <Warp/Common.hpp>
#include <Warp/Utilities.hpp>
#include <Warp/Testing/ParseTestingUtilities.hpp>
#include <Warp/Parsing/FunctionDeclarations.hpp>
#include <Warp/Runtime/Compiler/SimpleExecutor.hpp>
/* This work is under the Copyright Christopher A. Greeley (2024) and it is distributed
* under the No Kill Do No Harm License, a legally non-binding sumemry is as follows: 
* 
* # No Kill Do No Harm Licence â€“ Summary
* 
* Based on version 0.3, July 2022 of the Do No Harm License
* 
* https://github.com/raisely/NoHarm
* 
* LEGALLY NON-BINDING SUMMARY OF THE TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
* 
* ## Licence Grants
* 
* You're allowed
* 
* - to distribute the licensed work,
* - to create, publish, sublicense and patent derivative works and
* - to put your modifications or your derivative work under a seperate licence,
* 
* free of charge. Though, filing patent litigation leads to the loss of the patent licence. Also, the licence grants don't include the right to use the licensor's trademarks.
* 
* ## Unethical Behaviour
* 
* You may not use the licensed work if you engage in:
* 
* - human rights violations,
* - environmental destruction,
* - warfare,
* - addictive/destructive products or services or
* - actions that frustrate:
*   * peace,
*   * access to human rights,
*   * peaceful assembly and association,
*   * a sustainable environment or
*   * democratic processes
*   * abortion
*   * euthanasia
*   * human embryonic stem cell research (if human organisms are killed in the process)
* - except for actions that may be contrary to "human rights" (or interpretations thereof), do not kill and that frustrate 
*   * abortion
*   * euthanasia
*   * killing
* and; the software must never be used to kill, including: abortion, euthanasia, human stem cell research, in war, or law enforcement or as a part of any lethal weapon
* 
* ## Contributions
* 
* Contributions to the licensed work must be licensed under the exact same licence.
* 
* ## Licence Notice
* 
* When distributing the licensed work or your derivative work, you must
* 
* - include a copy of this licence,
* - retain attribution notices,
* - state changes that you made and
* - not use the names of the author and the contributors to promote your derivative work.
* 
* If the licensed work includes a "NOTICE" text file with attribution notices, you must copy those notices to:
* 
* - a "NOTICE" file within your derivative work,
* - a place within the source code or the documentation or
* - a place within a display generated by your derivative work.
* 
* ## No Warranty or Liability
* 
* The licensed work is offered on an as-is basis without any warranty or liability. You may choose to offer warranty or liability for your derivative work, but only fully on your own responsibility. */



#ifndef WARP__PARSING__HEADER__PARSING__CONSTANT__TESTS__HPP
#define WARP__PARSING__HEADER__PARSING__CONSTANT__TESTS__HPP

namespace Warp::Testing
{
	using namespace Utilities;
	using namespace Parsing;
	using namespace Runtime::Compiler::SimpleExecutor;
	
	using WholeType = NumericTypeResolver<NumericTypeTag::Whole>::Type;
	using IntegerType = NumericTypeResolver<NumericTypeTag::Integer>::Type;
	using FixedType = NumericTypeResolver<NumericTypeTag::FixedPoint>::Type;
	using CharType = NumericTypeResolver<NumericTypeTag::Character>::Type;
	using BoolType = NumericTypeResolver<NumericTypeTag::Bool>::Type;
	
	using NumericConstantType = Constant<SyntaxNode, NumericTypeTag>;
	using NumericContexType = std::unordered_map<std::string, NumericConstantType>;
	
	template<
			auto TypeTagParameterConstant, 
			template<auto> typename TypeResolverParameterTemplate = NumericTypeResolver
		>
	auto retrieve_constant(const OptionalConcept auto& context, std::string name, bool debug)
	{
		if(debug == true)
		{
			if(context.has_value() == false)
				std::cerr << "retrieve_constant::Error: NO CONTEXT\n";
			std::cout << "retrieve_constant: Requested constant: " << name << "\n";
			if(context.value().constants.contains(name) == false)
				std::cerr << "retrieve_constant::Error: No constant with requested name!\n";
		}
		const auto value = retrieve_value<
				typename TypeResolverParameterTemplate<TypeTagParameterConstant>::Type
			>(&context.value(), context.value().constants.at(name).value.get(), debug);
		if(debug == true && value.has_value() == false)
			std::cerr << "retrieve_constant::Error: No value for constant retrieved!\n";
		return value.value();
	}
	
	template<
			auto TypeTagParameterConstant,
			template<auto> typename TypeResolverParameterTemplate = NumericTypeResolver
		>
	auto retrieve_constant(const OptionalConcept auto& constant, bool debug)
	{
		return retrieve_value<
				typename NumericTypeResolver<TypeTagParameterConstant>::Type
			>(debug, constant.value().value).value();
	}
	template<
			auto TypeTagParameterConstant, 
			template<auto> typename TypeResolverParameterTemplate = NumericTypeResolver
		>
	auto print_constant(const OptionalConcept auto& context, std::string name, bool debug, bool courtesy = true)
	{
		std::cout << "{" << name << ":" << to_string(retrieve_constant<
						TypeTagParameterConstant
					>(context, name, debug)) << "}"
				<< ((courtesy == false) ? "" : "\n");
	}

	template<
			auto TypeTagParameterConstant, 
			template<auto> typename TypeResolverParameterTemplate = NumericTypeResolver
		>
	auto print_constant(const OptionalConcept auto& constant, bool debug, bool courtesy = true) {
		std::cout << "{" << constant.name << ":" << to_string(retrieve_constant<
						TypeTagParameterConstant, 
						TypeResolverParameterTemplate
					>(constant, debug)) << "}"
				<< ((courtesy == false) ? "" : "\n");
	}
	
	bool check(auto left, auto right, bool debug)
	{
		bool equal = (left == right);
		if(equal == false)
			std::cout << "Check failed, with Actual: " << left << " vs Expected: " << right << "\n";
		return equal;
	}
	
	template<
			auto TestParameterConstant, 
			auto TypeTagParameterConstant, 
			typename ParserParameterType = NumericParserType, 
			template<auto> typename ResolverParameterTemplate = NumericTypeResolver
		>
	void check_context_constant(
			std::vector<std::string> names, 
			const auto expected, 
			bool debug = false, 
			std::source_location test_location = std::source_location::current()
		)
	{
		auto context = runtime_parse<
				ParserParameterType, 
				TestParameterConstant, 
				Construct::Context
			>(debug);
		if(const bool parse_success = (context.has_value() == true); parse_success == false)
		{
			std::cerr << "\n" << test_location.file_name() << ": " << test_location.line() << ": "
					<< "Failed to parse or retrieve constants from \"" 
					<< TestParameterConstant.string << "\"\n";
			CHECK((parse_success == true));
		}
		else
		{
			for(size_t ii = 0; ii < names.size(); ++ii)
			{
				auto result = retrieve_constant<
							TypeTagParameterConstant, 
							ResolverParameterTemplate
					>(
						context, 
						names[ii], 
						debug
					);
				if(debug == true)
					std::cout << "{" << names[ii] << ":" << to_string(result) << "}\n";
				if(const bool check_result = (result == expected[ii]);
						check_result == false)
				{
					std::cerr << "\n" << test_location.file_name() << ": " << test_location.line() << ": "
							<< "Check failed with " 
							<< names[ii] << " = " << to_string(result) << " and " 
							<< to_string(expected[ii]) << "\n";
					CHECK((check_result == true));
				}
			}
		}
	}
}

#endif // WARP__PARSING__HEADER__PARSING__CONSTANT__TESTS__HPP

