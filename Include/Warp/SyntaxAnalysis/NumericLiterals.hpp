#include <Warp/SyntaxAnalysis/SyntaxTree.hpp>
#include <Warp/Runtime/Compiler/NumericType.hpp>
/* This work is under the Copyright Christopher A. Greeley (2024) and it is distributed
* under the No Kill Do No Harm License, a legally non-binding sumemry is as follows: 
* 
* # No Kill Do No Harm Licence â€“ Summary
* 
* Based on version 0.3, July 2022 of the Do No Harm License
* 
* https://github.com/raisely/NoHarm
* 
* LEGALLY NON-BINDING SUMMARY OF THE TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
* 
* ## Licence Grants
* 
* You're allowed
* 
* - to distribute the licensed work,
* - to create, publish, sublicense and patent derivative works and
* - to put your modifications or your derivative work under a seperate licence,
* 
* free of charge. Though, filing patent litigation leads to the loss of the patent licence. Also, the licence grants don't include the right to use the licensor's trademarks.
* 
* ## Unethical Behaviour
* 
* You may not use the licensed work if you engage in:
* 
* - human rights violations,
* - environmental destruction,
* - warfare,
* - addictive/destructive products or services or
* - actions that frustrate:
*   * peace,
*   * access to human rights,
*   * peaceful assembly and association,
*   * a sustainable environment or
*   * democratic processes
*   * abortion
*   * euthanasia
*   * human embryonic stem cell research (if human organisms are killed in the process)
* - except for actions that may be contrary to "human rights" (or interpretations thereof), do not kill and that frustrate 
*   * abortion
*   * euthanasia
*   * killing
* and; the software must never be used to kill, including: abortion, euthanasia, human stem cell research, in war, or law enforcement or as a part of any lethal weapon
* 
* ## Contributions
* 
* Contributions to the licensed work must be licensed under the exact same licence.
* 
* ## Licence Notice
* 
* When distributing the licensed work or your derivative work, you must
* 
* - include a copy of this licence,
* - retain attribution notices,
* - state changes that you made and
* - not use the names of the author and the contributors to promote your derivative work.
* 
* If the licensed work includes a "NOTICE" text file with attribution notices, you must copy those notices to:
* 
* - a "NOTICE" file within your derivative work,
* - a place within the source code or the documentation or
* - a place within a display generated by your derivative work.
* 
* ## No Warranty or Liability
* 
* The licensed work is offered on an as-is basis without any warranty or liability. You may choose to offer warranty or liability for your derivative work, but only fully on your own responsibility. */



#ifndef WARP__PARSING__HEADER__SYNTAX__ANALYSIS__NUMERIC__LITERALS__HPP
#define WARP__PARSING__HEADER__SYNTAX__ANALYSIS__NUMERIC__LITERALS__HPP

namespace Warp::SyntaxAnalysis::SyntaxTree
{
	using namespace Warp::Runtime::Compiler;

	#define LITERAL_NODE(NODE_TYPE, SEARCH_TYPE) \
			template<> \
			struct Node<NodeType:: NODE_TYPE > : public BaseNode \
			{ \
				constexpr static const auto tag = NodeType:: NODE_TYPE ; \
				using NumericType =	typename NumericTypeResolver<NumericTypeTag :: SEARCH_TYPE>::Type; \
				NumericType value; \
				constexpr Node() noexcept = default; \
				constexpr Node(const Node& other) noexcept = default; \
				Node(Node&& other) noexcept = default; \
				constexpr Node& operator=(const Node& other) noexcept = default; \
				Node& operator=(Node&& other) noexcept = default; \
				constexpr Node(NumericType value) noexcept : value(value) {} \
				constexpr virtual BaseNode::ViewType to_view() const noexcept final { \
					return BaseNode::ViewType{this}; \
				} \
				constexpr virtual NodeType get_tag() const noexcept { \
					return tag; \
				} \
				operator NumericType() { \
					return value; \
				} \
				operator SyntaxNode() const noexcept { \
					return SyntaxNode{*this}; \
				} \
			}

	LITERAL_NODE(LiteralWhole, Whole);
	LITERAL_NODE(LiteralInteger, Integer);
	LITERAL_NODE(LiteralFixed, FixedPoint);
	LITERAL_NODE(LiteralCharacter, Character);
	LITERAL_NODE(LiteralBool, Bool);
	
	#undef LITERAL_NODE

	extern template struct Node<NodeType::LiteralWhole>;
	extern template struct Node<NodeType::LiteralInteger>;
	extern template struct Node<NodeType::LiteralCharacter>;
	extern template struct Node<NodeType::LiteralFixed>;
	extern template struct Node<NodeType::LiteralBool>;
}

namespace std
{
	using namespace Warp::Runtime::Compiler;
	using namespace Warp::SyntaxAnalysis::SyntaxTree;

	extern template class std::unique_ptr<Node<NodeType::LiteralWhole>>;
	extern template class std::unique_ptr<Node<NodeType::LiteralInteger>>;
	extern template class std::unique_ptr<Node<NodeType::LiteralCharacter>>;
	extern template class std::unique_ptr<Node<NodeType::LiteralFixed>>;
	extern template class std::unique_ptr<Node<NodeType::LiteralBool>>;

	extern template std::unique_ptr<Node<NodeType::LiteralWhole>> std::make_unique<
			Node<NodeType::LiteralWhole>
		>(decltype(std::declval<NumericTypeResolver<NumericTypeTag::Whole>::Type>()));

	extern template std::unique_ptr<Node<NodeType::LiteralInteger>> std::make_unique<
			Node<NodeType::LiteralInteger>
		>(decltype(std::declval<NumericTypeResolver<NumericTypeTag::Integer>::Type>()));

	extern template std::unique_ptr<Node<NodeType::LiteralCharacter>> std::make_unique<
			Node<NodeType::LiteralCharacter>
		>(decltype(std::declval<NumericTypeResolver<NumericTypeTag::Character>::Type>()));

	extern template std::unique_ptr<Node<NodeType::LiteralFixed>> std::make_unique<
			Node<NodeType::LiteralFixed>
		>(decltype(std::declval<NumericTypeResolver<NumericTypeTag::FixedPoint>::Type>()));

	extern template std::unique_ptr<Node<NodeType::LiteralBool>> std::make_unique<
			Node<NodeType::LiteralBool>
		>(decltype(std::declval<NumericTypeResolver<NumericTypeTag::Bool>::Type>()));
}

#endif // WARP__PARSING__HEADER__SYNTAX__ANALYSIS__NUMERIC__LITERALS__HPP

